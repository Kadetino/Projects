#include <stdio.h>
#include <locale.h>

/*
39.
A4. Дан массив A из 16 байтов. Он разбит последовательно на слова. Если младший байт больше старшего (числа беззнаковые), то
поменять их местами, одновременно помещая в массив B их первоначальные адреса. Сосчитать количество таких пар
*/

// очистка stdin
int clean_stdin() {
	int c, counter = -1;
	do {
		c = getchar();
		counter += 1;
	} while (c != '\n' && c != EOF);
	return counter;
}

int main() {
	setlocale(LC_ALL, "rus");
	short int N = 16, i, k = 0; // N и i - для циклов; k - счётчик пар
	int B[16]; //массивы, содержащие адреса выбранных элементов в виде слов (short int) или в виде двойных слов(int), т.к.в байте адреса не умещаются.

	int input; // для ввода элементов массива как int
	int temp = 0; // для проверки корректности ввода

	// Массив А и ввод: пре-заполненные в комментариях
	unsigned char A[16];
	//unsigned char A[16] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 128, 77, 89, 98, 43, 56 }; // Количество пар: 7
	//unsigned char A[16] = { 1, 2, 3, 4, 9, 6, 8, 62, 7, 8, 9, 10, 129, 11, 12, 12 }; // Количество пар: 5
	//unsigned char A[16] = { 1, 9, 4, 4, 6, 6, 8, 128, 7, 8, 10, 10, 129, 11, 12, 12 }; // Количество пар: 3
	//unsigned char A[16] = { 2, 2, 4, 4, 6, 6, 8, 128, 7, 8, 10, 10, 129, 11, 12, 12 }; // Количество пар: 2
	//unsigned char A[16] = { 1, 1, 2, 2, 5, 5, 7, 7, 128, 128, 77, 77, 98, 98, 56, 56 }; // Массив В пуст
	
	printf("Введите массив А: ");
	for (i = 0; i < N; i++) {
		temp = scanf_s("%d", &input);
		clean_stdin();
		while (!temp) {
			printf("\nerror - Введите число: ");
			temp = scanf_s("%d", &input);
			clean_stdin();
		}
		A[i] = (unsigned char)input;
	}
	

	// Вывод старого массива
	printf("\n\nВведенный массив А = [");
	for (i = 0; i < N; i += 2)
		printf("%d, %d | ", A[i], A[i + 1]);
	__asm {
		;// Инициализация
		mov cx, 8; // Задать cx на 8 итераций
		lea esi, A; // адрес начала массива А в esi
		lea edi, B; // адрес начала массива В в edi
		mov k, 0; // счетчик "количества таких пар"

		;// Цикл
	LOOPSTART: mov bl, [esi]; // очередной старший байт из А в регистр bl
		inc esi; // Получить адрес младшего байта
		mov bh, [esi]; // очередной младший байт из А в регистр bh
		dec esi; // Вернуть адрес старшего байта

		;// Сравнение
		cmp bl, bh; // Сравнение старшего и младшего байтов
		jae NEXTELEMENT; // Старший байт больше младшего

		;// Свап местами и добавление первоначальных адресов в другой массив
		mov[edi], esi; // Адрес старшего байта поместить в B
		mov[esi], bh; // Положить младший байт на место старшего
		inc esi; // Перейти к адресу младшего байта
		inc edi; // Перейти к следующему адресу B
		mov[edi], esi; // Адрес младщего байта поместить в B
		mov[esi], bl; // Положить старший байт на место младшего

		;// Вернуть адреса "на место"
		dec esi; // Перейти к стартовому адресу A
		inc edi; // Перейти к следующему адресу B
		inc k; // увеличить счётчик пар

	NEXTELEMENT: inc esi; // увеличение адреса массива А на ...
		inc esi; // увеличение адреса массива А на 2
		loop LOOPSTART; // Конец итерации, начало следующей, если cx позволяет.
	}

	// Вывод нового массива
	printf("\b\b]\n    Новый массив А = [");
	for (i = 0; i < N; i += 2)
		printf("%d, %d | ", A[i], A[i + 1]);
	printf("\b\b]\n");
	
	// Вывод массива адресов
	if (k == 0) printf("\nМассив В пуст");
	else {
		printf("\nМассив В = [");
		for (i = 0; i < k * 2; i += 2)
			//printf("%x, ", B[i]);
			printf("%x, %x | ", B[i], B[i + 1]);
		printf("\b\b]\n");
	}

	// Количество пар
	printf("\n\nКоличество пар: %d", k);

	printf("\nПрограмма завершена\n");
	return 0;
}